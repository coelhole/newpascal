% Generated by https://pasdoc.github.io/PasDoc 0.16.0
\documentclass{report}
\usepackage{hyperref}
% WARNING: THIS SHOULD BE MODIFIED DEPENDING ON THE LETTER/A4 SIZE
\oddsidemargin 0cm
\evensidemargin 0cm
\marginparsep 0cm
\marginparwidth 0cm
\parindent 0cm
\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-2in}


% Conditional define to determine if pdf output is used
\newif\ifpdf
\ifx\pdfoutput\undefined
\pdffalse
\else
\pdfoutput=1
\pdftrue
\fi

\ifpdf
  \usepackage[pdftex]{graphicx}
\else
  \usepackage[dvips]{graphicx}
\fi

% Write Document information for pdflatex/pdftex
\ifpdf
\pdfinfo{
 /Author     (Pasdoc)
 /Title      (NewPascal)
}
\fi


% definitons for warning and note tag
\usepackage[most]{tcolorbox}
\newtcolorbox{tcbwarning}{
 breakable,
 enhanced jigsaw,
 top=0pt,
 bottom=0pt,
 titlerule=0pt,
 bottomtitle=0pt,
 rightrule=0pt,
 toprule=0pt,
 bottomrule=0pt,
 colback=white,
 arc=0pt,
 outer arc=0pt,
 title style={white},
 fonttitle=\color{black}\bfseries,
 left=8pt,
 colframe=red,
 title={Warning:},
}
\newtcolorbox{tcbnote}{
 breakable,
 enhanced jigsaw,
 top=0pt,
 bottom=0pt,
 titlerule=0pt,
 bottomtitle=0pt,
 rightrule=0pt,
 toprule=0pt,
 bottomrule=0pt,
 colback=white,
 arc=0pt,
 outer arc=0pt,
 title style={white},
 fonttitle=\color{black}\bfseries,
 left=8pt,
 colframe=yellow,
 title={Note:},
}

\begin{document}
\title{NewPascal}
\author{Pasdoc}
\maketitle
\newpage
\label{toc}\tableofcontents
\newpage
% special variable used for calculating some widths.
\newlength{\tmplength}
\chapter{Unit NewPascal.Base}
\label{NewPascal.Base}
\index{NewPascal.Base}
\section{Description}
Provides fundamental classes to NewPascal programming library.
\section{Uses}
\begin{itemize}
\item \begin{ttfamily}Classes\end{ttfamily}\item \begin{ttfamily}SysUtils\end{ttfamily}\end{itemize}
\section{Overview}
\begin{description}
\item[\texttt{\begin{ttfamily}Cloneable\end{ttfamily} Interface}]
\item[\texttt{\begin{ttfamily}Objct\end{ttfamily} Class}]
\item[\texttt{\begin{ttfamily}Excptn\end{ttfamily} Class}]
\item[\texttt{\begin{ttfamily}Error\end{ttfamily} Class}]
\item[\texttt{\begin{ttfamily}CloneNotSupportedException\end{ttfamily} Class}]
\item[\texttt{\begin{ttfamily}RuntimeException\end{ttfamily} Class}]
\item[\texttt{\begin{ttfamily}IllegalArgumentException\end{ttfamily} Class}]
\end{description}
\section{Classes, Interfaces, Objects and Records}
\ifpdf
\subsection*{\large{\textbf{Cloneable Interface}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Cloneable Interface}
\fi
\label{NewPascal.Base.Cloneable}
\index{Cloneable}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
Cloneable {$>$} IInterface
%%%%Description
\subsubsection*{\large{\textbf{Methods}}\normalsize\hspace{1ex}\hfill}
\paragraph*{Clone}\hspace*{\fill}

\label{NewPascal.Base.Cloneable-Clone}
\index{Clone}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public function Clone: Objct;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{Objct Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Objct Class}
\fi
\label{NewPascal.Base.Objct}
\index{Objct}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
Objct {$>$} TInterfacedObject
%%%%Description
\subsubsection*{\large{\textbf{Methods}}\normalsize\hspace{1ex}\hfill}
\paragraph*{Clone}\hspace*{\fill}

\label{NewPascal.Base.Objct-Clone}
\index{Clone}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected function Clone: Objct; virtual;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{ToString}\hspace*{\fill}

\label{NewPascal.Base.Objct-ToString}
\index{ToString}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public function ToString: AnsiString; override;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{Excptn Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Excptn Class}
\fi
\label{NewPascal.Base.Excptn}
\index{Excptn}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
Excptn {$>$} \begin{ttfamily}Objct\end{ttfamily}(\ref{NewPascal.Base.Objct}) {$>$} 
TInterfacedObject
%%%%Description
\subsubsection*{\large{\textbf{Properties}}\normalsize\hspace{1ex}\hfill}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Message}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\label{NewPascal.Base.Excptn-Message}
\index{Message}
\item[\textbf{Message}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property Message : string read fmessage;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \end{list}
\subsubsection*{\large{\textbf{Methods}}\normalsize\hspace{1ex}\hfill}
\paragraph*{Create}\hspace*{\fill}

\label{NewPascal.Base.Excptn-Create}
\index{Create}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public constructor Create(const msg : string = ''); overload;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{Create}\hspace*{\fill}

\label{NewPascal.Base.Excptn-Create}
\index{Create}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public constructor Create(const msg : string; const args : array of const); overload;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{Error Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Error Class}
\fi
\label{NewPascal.Base.Error}
\index{Error}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
Error {$>$} \begin{ttfamily}Excptn\end{ttfamily}(\ref{NewPascal.Base.Excptn}) {$>$} \begin{ttfamily}Objct\end{ttfamily}(\ref{NewPascal.Base.Objct}) {$>$} 
TInterfacedObject
%%%%Description
\ifpdf
\subsection*{\large{\textbf{CloneNotSupportedException Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{CloneNotSupportedException Class}
\fi
\label{NewPascal.Base.CloneNotSupportedException}
\index{CloneNotSupportedException}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
CloneNotSupportedException {$>$} \begin{ttfamily}Excptn\end{ttfamily}(\ref{NewPascal.Base.Excptn}) {$>$} \begin{ttfamily}Objct\end{ttfamily}(\ref{NewPascal.Base.Objct}) {$>$} 
TInterfacedObject
%%%%Description
\ifpdf
\subsection*{\large{\textbf{RuntimeException Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{RuntimeException Class}
\fi
\label{NewPascal.Base.RuntimeException}
\index{RuntimeException}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
RuntimeException {$>$} \begin{ttfamily}Excptn\end{ttfamily}(\ref{NewPascal.Base.Excptn}) {$>$} \begin{ttfamily}Objct\end{ttfamily}(\ref{NewPascal.Base.Objct}) {$>$} 
TInterfacedObject
%%%%Description
\ifpdf
\subsection*{\large{\textbf{IllegalArgumentException Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{IllegalArgumentException Class}
\fi
\label{NewPascal.Base.IllegalArgumentException}
\index{IllegalArgumentException}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
IllegalArgumentException {$>$} \begin{ttfamily}RuntimeException\end{ttfamily}(\ref{NewPascal.Base.RuntimeException}) {$>$} \begin{ttfamily}Excptn\end{ttfamily}(\ref{NewPascal.Base.Excptn}) {$>$} \begin{ttfamily}Objct\end{ttfamily}(\ref{NewPascal.Base.Objct}) {$>$} 
TInterfacedObject
%%%%Description
\section{Types}
\ifpdf
\subsection*{\large{\textbf{SByte}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SByte}
\fi
\label{NewPascal.Base-SByte}
\index{SByte}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SByte = ShortInt;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{ShortInt} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{Short}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Short}
\fi
\label{NewPascal.Base-Short}
\index{Short}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
Short = SmallInt;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{SmallInt} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{UShort}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{UShort}
\fi
\label{NewPascal.Base-UShort}
\index{UShort}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
UShort = Word;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{Word} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{Int}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Int}
\fi
\label{NewPascal.Base-Int}
\index{Int}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
Int = Int32;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{Int32} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{UInt}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{UInt}
\fi
\label{NewPascal.Base-UInt}
\index{UInt}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
UInt = LongWord;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{LongWord} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{Long}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Long}
\fi
\label{NewPascal.Base-Long}
\index{Long}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
Long = Int64;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{Int64} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{ULong}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ULong}
\fi
\label{NewPascal.Base-ULong}
\index{ULong}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ULong = QWord;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{QWord} integer type

\end{list}
\ifpdf
\subsection*{\large{\textbf{Float}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Float}
\fi
\label{NewPascal.Base-Float}
\index{Float}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
Float = Single;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \textit{Single} floating type

\end{list}
\ifpdf
\subsection*{\large{\textbf{ByteArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ByteArray}
\fi
\label{NewPascal.Base-ByteArray}
\index{ByteArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ByteArray = array of Byte;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{SByteArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SByteArray}
\fi
\label{NewPascal.Base-SByteArray}
\index{SByteArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SByteArray = array of SByte;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{ShortArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ShortArray}
\fi
\label{NewPascal.Base-ShortArray}
\index{ShortArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ShortArray = array of Short;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{UShortArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{UShortArray}
\fi
\label{NewPascal.Base-UShortArray}
\index{UShortArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
UShortArray = array of UShort;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{IntArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{IntArray}
\fi
\label{NewPascal.Base-IntArray}
\index{IntArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
IntArray = array of Int;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{UIntArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{UIntArray}
\fi
\label{NewPascal.Base-UIntArray}
\index{UIntArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
UIntArray = array of UInt;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{LongArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{LongArray}
\fi
\label{NewPascal.Base-LongArray}
\index{LongArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
LongArray = array of Long;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{ULongArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ULongArray}
\fi
\label{NewPascal.Base-ULongArray}
\index{ULongArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ULongArray = array of ULong;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{DoubleArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{DoubleArray}
\fi
\label{NewPascal.Base-DoubleArray}
\index{DoubleArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
DoubleArray = array of Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{FloatArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{FloatArray}
\fi
\label{NewPascal.Base-FloatArray}
\index{FloatArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
FloatArray = array of Float;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{CurrencyArray}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{CurrencyArray}
\fi
\label{NewPascal.Base-CurrencyArray}
\index{CurrencyArray}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
CurrencyArray = array of Currency;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{ObjctClass}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ObjctClass}
\fi
\label{NewPascal.Base-ObjctClass}
\index{ObjctClass}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ObjctClass = class of Objct;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{ExceptnClass}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ExceptnClass}
\fi
\label{NewPascal.Base-ExceptnClass}
\index{ExceptnClass}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ExceptnClass = class of Excptn;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{ErrorClass}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{ErrorClass}
\fi
\label{NewPascal.Base-ErrorClass}
\index{ErrorClass}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
ErrorClass = class of Error;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{CloneNotSupportedExceptionClass}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{CloneNotSupportedExceptionClass}
\fi
\label{NewPascal.Base-CloneNotSupportedExceptionClass}
\index{CloneNotSupportedExceptionClass}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
CloneNotSupportedExceptionClass = class of CloneNotSupportedException;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{RuntimeExceptionClass}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{RuntimeExceptionClass}
\fi
\label{NewPascal.Base-RuntimeExceptionClass}
\index{RuntimeExceptionClass}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
RuntimeExceptionClass = class of RuntimeException;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{IllegalArgumentExceptionClass}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{IllegalArgumentExceptionClass}
\fi
\label{NewPascal.Base-IllegalArgumentExceptionClass}
\index{IllegalArgumentExceptionClass}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
IllegalArgumentExceptionClass = class of IllegalArgumentException;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\section{Constants}
\ifpdf
\subsection*{\large{\textbf{Null}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{Null}
\fi
\label{NewPascal.Base-Null}
\index{Null}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
Null : pointer = Nil;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
an alias to \begin{ttfamily}Nil\end{ttfamily} pointer constant

\end{list}
\chapter{Unit NewPascal.GUI.Geom}
\label{NewPascal.GUI.Geom}
\index{NewPascal.GUI.Geom}
\section{Description}
Provides classes for defining and performing operations on objects related to two{-}dimensional geometry.
\section{Uses}
\begin{itemize}
\item \begin{ttfamily}Classes\end{ttfamily}\item \begin{ttfamily}SysUtils\end{ttfamily}\item \begin{ttfamily}NewPascal.Base\end{ttfamily}(\ref{NewPascal.Base})\end{itemize}
\section{Overview}
\begin{description}
\item[\texttt{\begin{ttfamily}PathIterator\end{ttfamily} Interface}]The PathIterator interface provides the mechanism for objects that implement the Shape interface to return the geometry of their boundary by allowing a caller to retrieve the path of that boundary a segment at a time.
\item[\texttt{\begin{ttfamily}AffineTransform\end{ttfamily} Class}]
\end{description}
\section{Classes, Interfaces, Objects and Records}
\ifpdf
\subsection*{\large{\textbf{PathIterator Interface}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{PathIterator Interface}
\fi
\label{NewPascal.GUI.Geom.PathIterator}
\index{PathIterator}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
PathIterator {$>$} IInterface
\subsubsection*{\large{\textbf{Description}}\normalsize\hspace{1ex}\hfill}
The PathIterator interface provides the mechanism for objects that implement the Shape interface to return the geometry of their boundary by allowing a caller to retrieve the path of that boundary a segment at a time. This interface allows these objects to retrieve the path of their boundary a segment at a time by using 1st through 3rd order Bézier curves, which are lines and quadratic or cubic Bézier splines. Multiple subpaths can be expressed by using a "MOVETO" segment to create a discontinuity in the geometry to move from the end of one subpath to the beginning of the next.

Each subpath can be closed manually by ending the last segment in the subpath on the same coordinate as the beginning "MOVETO" segment for that subpath or by using a "CLOSE" segment to append a line segment from the last point back to the first. Be aware that manually closing an outline as opposed to using a "CLOSE" segment to close the path might result in different line style decorations being used at the end points of the subpath. For example, the BasicStroke object uses a line "JOIN" decoration to connect the first and last points if a "CLOSE" segment is encountered, whereas simply ending the path on the same coordinate as the beginning coordinate results in line "CAP" decorations being used at the ends.\subsubsection*{\large{\textbf{Methods}}\normalsize\hspace{1ex}\hfill}
\paragraph*{GetWindingRule}\hspace*{\fill}

\label{NewPascal.GUI.Geom.PathIterator-GetWindingRule}
\index{GetWindingRule}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public function GetWindingRule: Int;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
Returns the winding rule for determining the interior of the path.   \par
\item[\textbf{Returns}]the winding rule
\item[\textbf{See also}]
\begin{description}
\item[\begin{ttfamily}WIND{\_}EVEN{\_}ODD\end{ttfamily}(\ref{NewPascal.GUI.Geom-WIND_EVEN_ODD})] 
The winding rule constant for specifying an even{-}odd rule for determining the interior of a path.
\item[\begin{ttfamily}WIND{\_}NON{\_}ZERO\end{ttfamily}(\ref{NewPascal.GUI.Geom-WIND_NON_ZERO})] 
The winding rule constant for specifying a non{-}zero rule for determining the interior of a path.
\end{description}


\end{list}
\paragraph*{IsDone}\hspace*{\fill}

\label{NewPascal.GUI.Geom.PathIterator-IsDone}
\index{IsDone}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public function IsDone: Boolean;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
Tests if the iteration is complete. \par
\item[\textbf{Returns}]\begin{ttfamily}True\end{ttfamily} if all the segments have been read; \begin{ttfamily}False\end{ttfamily} otherwise.


\end{list}
\paragraph*{Next}\hspace*{\fill}

\label{NewPascal.GUI.Geom.PathIterator-Next}
\index{Next}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public procedure Next;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
Moves the iterator to the next segment of the path forwards along the primary direction of traversal as long as there are more points in that direction.

\end{list}
\paragraph*{CurrentSegment}\hspace*{\fill}

\label{NewPascal.GUI.Geom.PathIterator-CurrentSegment}
\index{CurrentSegment}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public function CurrentSegment(Coords : DoubleArray) : Int;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\ifpdf
\subsection*{\large{\textbf{AffineTransform Class}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{AffineTransform Class}
\fi
\label{NewPascal.GUI.Geom.AffineTransform}
\index{AffineTransform}
\subsubsection*{\large{\textbf{Hierarchy}}\normalsize\hspace{1ex}\hfill}
AffineTransform {$>$} \begin{ttfamily}Objct\end{ttfamily}(\ref{NewPascal.Base.Objct}) {$>$} 
TInterfacedObject
%%%%Description
\subsubsection*{\large{\textbf{Properties}}\normalsize\hspace{1ex}\hfill}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{FlatMatrix}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\label{NewPascal.GUI.Geom.AffineTransform-FlatMatrix}
\index{FlatMatrix}
\item[\textbf{FlatMatrix}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property FlatMatrix : DoubleArray read GetMatrix;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-ScaleX}
\index{ScaleX}
\item[\textbf{ScaleX}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property ScaleX : Double read M00;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-ScaleY}
\index{ScaleY}
\item[\textbf{ScaleY}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property ScaleY : Double read M11;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-ShearX}
\index{ShearX}
\item[\textbf{ShearX}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property ShearX : Double read M01;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-ShearY}
\index{ShearY}
\item[\textbf{ShearY}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property ShearY : Double read M10;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TranslateX}
\index{TranslateX}
\item[\textbf{TranslateX}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property TranslateX : Double read M02;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TranslateY}
\index{TranslateY}
\item[\textbf{TranslateY}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public property TranslateY : Double read M12;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \end{list}
\subsubsection*{\large{\textbf{Fields}}\normalsize\hspace{1ex}\hfill}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{TYPE{\_}QUADRANT{\_}ROTATION}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\label{NewPascal.GUI.Geom.AffineTransform-TYPE_IDENTITY}
\index{TYPE{\_}IDENTITY}
\item[\textbf{TYPE{\_}IDENTITY}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}IDENTITY            : Int = 0;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_TRANSLATION}
\index{TYPE{\_}TRANSLATION}
\item[\textbf{TYPE{\_}TRANSLATION}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}TRANSLATION         : Int = 1;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_UNIFORM_SCALE}
\index{TYPE{\_}UNIFORM{\_}SCALE}
\item[\textbf{TYPE{\_}UNIFORM{\_}SCALE}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}UNIFORM{\_}SCALE       : Int = 2;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_GENERAL_SCALE}
\index{TYPE{\_}GENERAL{\_}SCALE}
\item[\textbf{TYPE{\_}GENERAL{\_}SCALE}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}GENERAL{\_}SCALE       : Int = 4;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_MASK_SCALE}
\index{TYPE{\_}MASK{\_}SCALE}
\item[\textbf{TYPE{\_}MASK{\_}SCALE}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}MASK{\_}SCALE          : Int = (2 or 4);\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_FLIP}
\index{TYPE{\_}FLIP}
\item[\textbf{TYPE{\_}FLIP}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}FLIP                : Int = 64;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_QUADRANT_ROTATION}
\index{TYPE{\_}QUADRANT{\_}ROTATION}
\item[\textbf{TYPE{\_}QUADRANT{\_}ROTATION}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}QUADRANT{\_}ROTATION   : Int = 8;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_GENERAL_ROTATION}
\index{TYPE{\_}GENERAL{\_}ROTATION}
\item[\textbf{TYPE{\_}GENERAL{\_}ROTATION}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}GENERAL{\_}ROTATION    : Int = 16;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_MASK_ROTATION}
\index{TYPE{\_}MASK{\_}ROTATION}
\item[\textbf{TYPE{\_}MASK{\_}ROTATION}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}MASK{\_}ROTATION       : Int = (8 or 16);\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-TYPE_GENERAL_TRANSFORM}
\index{TYPE{\_}GENERAL{\_}TRANSFORM}
\item[\textbf{TYPE{\_}GENERAL{\_}TRANSFORM}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public const TYPE{\_}GENERAL{\_}TRANSFORM   : Int = 32;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-M00}
\index{M00}
\item[\textbf{M00}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected M00: Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-M10}
\index{M10}
\item[\textbf{M10}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected M10: Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-M01}
\index{M01}
\item[\textbf{M01}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected M01: Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-M11}
\index{M11}
\item[\textbf{M11}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected M11: Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-M02}
\index{M02}
\item[\textbf{M02}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected M02: Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-M12}
\index{M12}
\item[\textbf{M12}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected M12: Double;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-State}
\index{State}
\item[\textbf{State}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected State: Int;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-APPLY_IDENTITY}
\index{APPLY{\_}IDENTITY}
\item[\textbf{APPLY{\_}IDENTITY}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected const APPLY{\_}IDENTITY           : Int = 0;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-APPLY_TRANSLATE}
\index{APPLY{\_}TRANSLATE}
\item[\textbf{APPLY{\_}TRANSLATE}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected const APPLY{\_}TRANSLATE          : Int = 1;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-APPLY_SCALE}
\index{APPLY{\_}SCALE}
\item[\textbf{APPLY{\_}SCALE}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected const APPLY{\_}SCALE              : Int = 2;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \label{NewPascal.GUI.Geom.AffineTransform-APPLY_SHEAR}
\index{APPLY{\_}SHEAR}
\item[\textbf{APPLY{\_}SHEAR}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected const APPLY{\_}SHEAR              : Int = 4;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi


\par  \end{list}
\subsubsection*{\large{\textbf{Methods}}\normalsize\hspace{1ex}\hfill}
\paragraph*{Create}\hspace*{\fill}

\label{NewPascal.GUI.Geom.AffineTransform-Create}
\index{Create}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public constructor Create; overload;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{Create}\hspace*{\fill}

\label{NewPascal.GUI.Geom.AffineTransform-Create}
\index{Create}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public constructor Create(Tx : AffineTransform); overload;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{Create}\hspace*{\fill}

\label{NewPascal.GUI.Geom.AffineTransform-Create}
\index{Create}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public constructor Create(const m00, m10, m01, m11, m02, m12 : Double); overload;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{Create}\hspace*{\fill}

\label{NewPascal.GUI.Geom.AffineTransform-Create}
\index{Create}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public constructor Create(FlatMatrix : DoubleArray); overload;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{Clone}\hspace*{\fill}

\label{NewPascal.GUI.Geom.AffineTransform-Clone}
\index{Clone}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
public function Clone: Objct; override;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\paragraph*{UpdateState}\hspace*{\fill}

\label{NewPascal.GUI.Geom.AffineTransform-UpdateState}
\index{UpdateState}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
protected procedure UpdateState;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\end{list}
\section{Constants}
\ifpdf
\subsection*{\large{\textbf{WIND{\_}EVEN{\_}ODD}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{WIND{\_}EVEN{\_}ODD}
\fi
\label{NewPascal.GUI.Geom-WIND_EVEN_ODD}
\index{WIND{\_}EVEN{\_}ODD}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
WIND{\_}EVEN{\_}ODD  : Int = 0;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The winding rule constant for specifying an even{-}odd rule for determining the interior of a path.

\end{list}
\ifpdf
\subsection*{\large{\textbf{WIND{\_}NON{\_}ZERO}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{WIND{\_}NON{\_}ZERO}
\fi
\label{NewPascal.GUI.Geom-WIND_NON_ZERO}
\index{WIND{\_}NON{\_}ZERO}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
WIND{\_}NON{\_}ZERO  : Int = 1;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The winding rule constant for specifying a non{-}zero rule for determining the interior of a path. The non{-}zero rule specifies that a point lies inside the path if a ray drawn in any direction from that point to infinity is crossed by path segments a different number of times in the counter{-}clockwise direction than the clockwise direction.

\end{list}
\ifpdf
\subsection*{\large{\textbf{SEG{\_}MOVETO}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SEG{\_}MOVETO}
\fi
\label{NewPascal.GUI.Geom-SEG_MOVETO}
\index{SEG{\_}MOVETO}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SEG{\_}MOVETO     : Int = 0;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The segment type constant for a point that specifies the starting location for a new subpath.

\end{list}
\ifpdf
\subsection*{\large{\textbf{SEG{\_}LINETO}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SEG{\_}LINETO}
\fi
\label{NewPascal.GUI.Geom-SEG_LINETO}
\index{SEG{\_}LINETO}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SEG{\_}LINETO     : Int = 1;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The segment type constant for a point that specifies the end point of a line to be drawn from the most recently specified point.

\end{list}
\ifpdf
\subsection*{\large{\textbf{SEG{\_}QUADTO}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SEG{\_}QUADTO}
\fi
\label{NewPascal.GUI.Geom-SEG_QUADTO}
\index{SEG{\_}QUADTO}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SEG{\_}QUADTO     : Int = 2;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The segment type constant for the pair of points that specify a quadratic parametric curve to be drawn from the most recently specified point. The curve is interpolated by solving the parametric control equation in the range (t=[0..1]) using the most recently specified (current) point (CP), the first control point (P1), and the final interpolated control point (P2). The parametric control equation for this curve is: P(t) = B(2,0)*CP + B(2,1)*P1 + B(2,2)*P2 0 {$<$}= t {$<$}= 1

B(n,m) = mth coefficient of nth degree Bernstein polynomial = C(n,m) * t{\^{}}(m) * (1 {-} t){\^{}}(n{-}m) C(n,m) = Combinations of n things, taken m at a time = n! / (m! * (n{-}m)!)

\end{list}
\ifpdf
\subsection*{\large{\textbf{SEG{\_}CUBICTO}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SEG{\_}CUBICTO}
\fi
\label{NewPascal.GUI.Geom-SEG_CUBICTO}
\index{SEG{\_}CUBICTO}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SEG{\_}CUBICTO    : Int = 3;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The segment type constant for the set of 3 points that specify a cubic parametric curve to be drawn from the most recently specified point. The curve is interpolated by solving the parametric control equation in the range (t=[0..1]) using the most recently specified (current) point (CP), the first control point (P1), the second control point (P2), and the final interpolated control point (P3). The parametric control equation for this curve is: P(t) = B(3,0)*CP + B(3,1)*P1 + B(3,2)*P2 + B(3,3)*P3 0 {$<$}= t {$<$}= 1

B(n,m) = mth coefficient of nth degree Bernstein polynomial = C(n,m) * t{\^{}}(m) * (1 {-} t){\^{}}(n{-}m) C(n,m) = Combinations of n things, taken m at a time = n! / (m! * (n{-}m)!)

This form of curve is commonly known as a Bézier curve.

\end{list}
\ifpdf
\subsection*{\large{\textbf{SEG{\_}CLOSE}}\normalsize\hspace{1ex}\hrulefill}
\else
\subsection*{SEG{\_}CLOSE}
\fi
\label{NewPascal.GUI.Geom-SEG_CLOSE}
\index{SEG{\_}CLOSE}
\begin{list}{}{
\settowidth{\tmplength}{\textbf{Description}}
\setlength{\itemindent}{0cm}
\setlength{\listparindent}{0cm}
\setlength{\leftmargin}{\evensidemargin}
\addtolength{\leftmargin}{\tmplength}
\settowidth{\labelsep}{X}
\addtolength{\leftmargin}{\labelsep}
\setlength{\labelwidth}{\tmplength}
}
\item[\textbf{Declaration}\hfill]
\ifpdf
\begin{flushleft}
\fi
\begin{ttfamily}
SEG{\_}CLOSE      : Int = 4;\end{ttfamily}

\ifpdf
\end{flushleft}
\fi

\par
\item[\textbf{Description}]
The segment type constant that specifies that the preceding subpath should be closed by appending a line segment back to the point corresponding to the most recent SEG{\_}MOVETO.

\end{list}
\end{document}
